#!/usr/bin/env lua5.1
--[[
Use a combination of nfq and nfct to do userspace connection tracking for a sample RPC-like
service over TCP, that uses ephemeral persistent ports.

The server is the echoserver running on localhost, client is the echoclient.

Start server:

    ./echoserver 9999

Test client:

    ./echoclient localhost 9999 hello world

Kill it after a few connections.

Start conntracker:

    sudo ./echoconntracker port=9999 verbose=y

Try client again... kill conntracker...

To clear the conntracker's rules:

    sudo ./echoconntracker port=9999 verbose=y clear=y

]]

require"nfct"
require"nfq"
require"net"

local function debug(...) end
local function verbose(...) end

-- arguments

function usage(k)
    if arg[k] then
        return
    end
    print("arg '"..k.."' not provided")
    print("usage "..arg[0].." port=num [clear=y] [verbose=y|very]")
    os.exit(1)
end

for i,a in ipairs(arg) do
    local s,e,k,v = a:find("^([^=]+)=(.*)$")
    arg[k] = v
end

usage"port"

if arg.verbose then verbose = print end
if arg.verbose == "very" then
    debug = print
end

-- iptables rule setup

local function execute(cmd)
    if type(cmd) == "table" then
        cmd = table.concat(cmd, " ")
    end
    print("cmd=<"..cmd..">")
    local status = os.execute(cmd)
    if status == 0 then
        return status
    end
    return nil, string.format("%q", cmd).." failed with "..status
end

function clear_filter(clear)
    execute"iptables -L -n"
    execute"iptables -P INPUT ACCEPT"
    execute"iptables -P OUTPUT ACCEPT"
    execute"iptables -P FORWARD ACCEPT"
    execute"iptables -F"
    execute"iptables -L -n"
    if clear then
        os.exit(0)
    end
end

--[[
What table means:

FORWARD - packets that traverse
OUTPUT  - packets we generate
INPUT   - packets we receive

Client/Server on localhost:

./echoportbroker 9999
while ./echoclient localhost 9999 hello world; do sleep 5; done
sudo ./inline-listen host=127.0.0.1 port=9999 table=OUTPUT

]]

-- TODO this assumes host is ourselves, tables would have to be different
-- if it was remote, or we were a firewall/forwarding traffic
function set_filter(port)
    local execute = function (cmd)
        assert(execute(cmd))
    end
    -- default for input is to DROP
    execute{
        "iptables -t filter",
        "-P INPUT DROP",
    }
    -- outgoing responses from server are queued
    execute{
        "iptables -t filter",
        "-A OUTPUT",
        "-p tcp",
        "--sport "..port,
        "-j QUEUE" -- queue 0 is implicit
    }
    -- incoming established connections accepted
    execute{
        "iptables -t filter",
        "-A INPUT",
        "-p tcp",
        "-m state --state RELATED,ESTABLISHED",
        "-j ACCEPT"
    }
    -- outgoing new and established connections accepted
    execute{
        "iptables -t filter",
        "-A OUTPUT",
        "-p tcp",
        "-m state --state NEW,RELATED,ESTABLISHED",
        "-j ACCEPT"
    }
    -- incoming connections to server are accepted
    execute{
        "iptables -t filter",
        "-A INPUT",
        "-p tcp",
        "--dport "..port,
        "-m state --state NEW",
        "-j ACCEPT",
    }

    execute"iptables -L -n"
end

clear_filter(arg.clear)

set_filter(arg.port)


-- nfct helpers

local function ctprint(ct, name, ...)
    print("ct="..nfct.tostring(ct).." -- "..name, ...)
end

local function expprint(exp, name, ...)
    print("exp="..nfct.exp_tostring(exp).." -- "..name, ...)
end

local function check(...)
    if (...) then
        return ...
    end
    local _, emsg, eno = ...
    local emsg = "["..tostring(eno).."] "..tostring(emsg)
    return assert(_, emsg)
end

local function tuple(name, src, dst, sport, dport)
    local ct = assert(nfct.new())

    nfct.set_attr_pf(ct, "l3proto",  "inet")
    nfct.set_attr_ipv4(ct, "ipv4-src", src)
    nfct.set_attr_ipv4(ct, "ipv4-dst", dst)

    nfct.set_attr_ipproto(ct, "l4proto",  "tcp")

    if sport then
        nfct.set_attr_port(ct, "port-src", sport)
    end

    nfct.set_attr_port(ct, "port-dst", dport)

    ctprint(ct, name)

    return ct
end

local function expect(src, dst, sport, dport, expectport)
    -- identify the master to which this expectation is related
    local master = tuple("master", src, dst, sport, dport)
    local expected = tuple("expected", src, dst, nil, expectport)
    local mask = tuple("mask", 0xffffffff, 0xffffffff, nil, expectport)
    local timeout = 10 -- seconds FIXME we need this to be longer than the real server's timeout
    local exp = assert(nfct.exp_new(master, expected, mask, timeout, "permanent"))

    nfct.destroy(master)
    nfct.destroy(expected)
    nfct.destroy(mask)

    expprint(exp, "expectation")

    local h = assert(nfct.open("expect"))

    -- FIXME this can fail if conntrack hasn't tracked the master... but is that possible? we just
    -- got data from nfq, the connection must exist
    check(nfct.exp_query(h, "create", exp))

    nfct.exp_destroy(exp)

    nfct.close(h)
end

-- Expectation tracking

local qhandle = assert(nfq.open())

nfq.unbind_pf(qhandle, "inet")
nfq.bind_pf(qhandle, "inet")

local queue = assert(nfq.create_queue(qhandle, 0))

assert(nfq.set_mode(queue, "packet"))

local n = net.init()

nfq.catch(qhandle, function (nfqdata)
    debug("CB nfq")

    local inip = assert(nfq.get_payload(nfqdata))

    n:clear()
    n:decode_ip(inip)

    local _, tcp = pcall(n.get_tcp, n)
    local _, ip = pcall(n.get_ipv4, n)

    if not tcp or not ip then
        -- not of requested protocol
        debug("ignore protocol", n:dump())
        return "accept"
    end

    -- Original connection was client->server, and this packet is
    -- server->client, so reverse src and dst
    local src, dst, sport, dport = ip.dst, ip.src, tcp.dst, tcp.src
    local indata = tcp.payload

    if indata then
        debug("data", indata)
        local expectport = tonumber(indata)
        if expectport ~= nil then
            verbose("Q", "master", src, dst, sport, dport)
            verbose("Q", "expect", src, dst, "*", expectport)
            expect(src, dst, sport, dport, expectport)
        end 
    else
        debug("Q", "flags", string.format("%#x", tcp.flags), "(non-data)")
    end

    return "accept"
end)

